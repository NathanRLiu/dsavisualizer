{"version":3,"sources":["reportWebVitals.js","HexNode.js","index.js"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","HexNode","innerHex","React","createRef","BoundingClientRect","getBoundingClientRect","bind","ReactDOM","findDOMNode","this","className","style","marginTop","props","y","marginLeft","x","ref","text","Component","xOffset","Node","val","value","children","newNode","push","getYOffsetFromXOffset","Math","tan","PI","page","widthList","root","createNode","counter","hasLeft","random","hasRight","thisNode","parseInt","addNode","traverse","node","iterations","nodeChildren","i","length","maxWidth","plot","currGen","currX","currY","multiplier","myNode","x1","x2","y1","y2","myHeight","renderedNode","render","document","getElementById","nmultiplier","isLeft","point1X","point2X","point1Y","point2Y","class","width","height","strokeWidth","stroke"],"mappings":"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","file":"static/js/main.27071470.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nclass HexNode extends React.Component {\n\tconstructor(){\n\t\tsuper();\n\t\tthis.innerHex = React.createRef();\n\t\tthis.BoundingClientRect = this.getBoundingClientRect.bind(this);\n\t}\n\tgetBoundingClientRect(){\n\t\treturn ReactDOM.findDOMNode(this).getBoundingClientRect();\n\t}\n\trender(){\n\t\treturn (\n\t\t\t\t<div className=\"hex outerHex\"style={\n\t\t\t\t\t{marginTop:this.props.y,\n\t\t\t\t\t marginLeft:this.props.x}}>\n\t\t\t\t\t<div className=\"hex innerHex\" ref={this.innerHex}>\n\t\t\t\t\t\t<p className=\"nodeText\">{this.props.text}</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t)\n\t}\n}\n\nexport default HexNode;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport HexNode from './HexNode.js'\n\nlet viewFrame = 75;\nlet VFUnits = \"%\";\nlet xOffset = 200;\nclass Node{\n\tconstructor(val){\n\t\tthis.value = val;\n\t\tthis.children = [];\n\t}\n\taddNode(newNode){\n\t\tthis.children.push(newNode);\n\t}\n}\n\nfunction getYOffsetFromXOffset(xOffset){\n\treturn xOffset * Math.tan(Math.PI / 3);\n}\n\nvar nodeList = [];\n\nvar page = [];\n\nfunction connectNodes(x1,x2, y1, y2, myHeight){\n\t//let x1 = node1.left + node1.right;\n\t//x1/=2;\n\t//let x2 = node2.left + node2.right;\n\t//x2/=2;\n\t//let y1 = node1.top + node1.bottom;\n\t//y1/=2;\n\t//let y2 = node2.top + node2.bottom;\n\t//y2/=2;\n\treturn(\n\t\t<svg class = \"connection\" style = {{width: myHeight * xOffset * myHeight/2 + widthList.length * xOffset * widthList.length/2,\n\t\t\theight: myHeight * getYOffsetFromXOffset(xOffset)}}>\n\t\t\t<line x1={x1} y2={y2} x2={x2} y1={y1} strokeWidth=\"5\"  stroke=\"currentColor\"/>\n\t\t</svg>)\n}\nfunction createNode(counter)\n{\n\tlet hasLeft = Math.random() < 0.5;\n\tlet hasRight = Math.random() < 0.5\n\tif (counter >= 6){\n\t\thasLeft = false\n\t\thasRight = false\n\t}\n\tlet thisNode = new Node(parseInt((Math.random() * 80),10))\n\tif (hasLeft){\n\t\tthisNode.addNode(createNode(counter + 1));\n\t}\n\tif (hasRight){\n\t\tthisNode.addNode(createNode(counter + 1));\n\t}\n\treturn thisNode\n}\nlet widthList = [];\nlet root = createNode(0);\n//let root = new Node(0);\n//let leftNode = new Node(1);\n//root.addNode(leftNode);\n//let rightNode = new Node(2);\n//root.addNode(rightNode);\n//leftNode.addNode(new Node(3));\n//rightNode.addNode(new Node(4));\n//leftNode.addNode(new Node(5));\n\nfunction traverse(node, iterations){\n\tconst nodeChildren = node.children;\n\tif (!widthList[iterations]){\n\t\twidthList.push(0);\n\t}\n\twidthList[iterations] += 1;\n\tfor (let i = 0; i < nodeChildren.length; i++){\n\t\ttraverse(nodeChildren[i], iterations + 1);\n\t}\n}\ntraverse(root, 0);\nfunction plot(node, currGen, currX, currY, multiplier){\n\tlet localXOffset = xOffset * (widthList.length - currGen)\n\tcurrX = currX + (multiplier * localXOffset)\n\tconst myNode = <HexNode text = {node.value} x = {currX} y = {currY}> </HexNode>\n\tpage.push(myNode)\n\tlet renderedNode = ReactDOM.render(myNode,document.getElementById('root'));\n\tlet connXOffset = 52;\n\tlet connYOffset = 30;\n\tfor (let i = 0; i < node.children.length; i++){\n\t\tvar nmultiplier = 0;\n\t\tif (node.children.length !== 1){\n\t\t\tconst isLeft = (i%2===0);\n\t\t\tif (isLeft){\n\t\t\t\tnmultiplier = -1;\n\t\t\t}\n\t\t\tif (!isLeft){\n\t\t\t\tnmultiplier = 1;\n\t\t\t}\n\n\t\t}else{\n\t\t\tconst isLeft = Math.random() < 0.5 + multiplier * .2\n\t\t\tif (isLeft){\n\t\t\t\tnmultiplier = -1;\n\t\t\t}\n\t\t\tif (!isLeft){\n\t\t\t\tnmultiplier = 1;\n\t\t\t}\n\t\t}\n\t\tplot(node.children[i], currGen + 1, currX, currY+getYOffsetFromXOffset(xOffset), nmultiplier);\n\n\t\tlet nextXOffset = xOffset * (widthList.length - (currGen + 1));\n\t\tlet point1X = currX + connXOffset //the current node, the position of the left side plus a variable x offset that determines the distance remaining to the center\n\t\tlet point2X = connXOffset + currX + nextXOffset * nmultiplier //same as above but we then calculate the offset that the next line will have\n\t\tlet point1Y = currY + connYOffset // the position of the top of the current node plus a variable offset determining distance to the center.\n\t\tlet point2Y = currY + connYOffset + getYOffsetFromXOffset(xOffset); //add the displacement for the next layer\n\n\t\tpage.push(connectNodes(point1X, point2X, point1Y, point2Y, widthList.length))\n\t\t\n\t}\n\treturn renderedNode;\n}\nlet maxWidth = 0;\n\nfor (let i = 0; i < widthList.length; i++){\n\tif (widthList[i] > maxWidth){\n\t\tmaxWidth = widthList[i];\n\t}\n}\nvar min = 2, max = 40;\n\nplot(root, 0, widthList.length * xOffset * widthList.length/2, 30, 0);\nReactDOM.render(\n\tpage,\n\tdocument.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}